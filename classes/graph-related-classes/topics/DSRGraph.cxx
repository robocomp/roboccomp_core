// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file DSRGraph.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "DSRGraph.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>
#include <iostream>
#include <string>

static constexpr std::array<std::string_view, 5> TYPENAMES_IDL_UNION = { "STRING", "INT", "FLOAT", "FLOAT_VEC", "BOOL" };

Val::Val()
{
    m__d = 0;
    // m_str com.eprosima.idl.parser.typecode.StringTypeCode@306279ee
    m_str ="";
    // m_dec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@545997b1
    m_dec = 0;
    // m_fl com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4cf4d528
    m_fl = 0.0;
    // m_float_vec com.eprosima.idl.parser.typecode.SequenceTypeCode@77846d2c

    // m_bl com.eprosima.idl.parser.typecode.PrimitiveTypeCode@548ad73b
    m_bl = false;
}

Val::~Val()
{
}

Val::Val(const Val &x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_str = x.m_str;
        break;
        case 1:
        m_dec = x.m_dec;
        break;
        case 2:
        m_fl = x.m_fl;
        break;
        case 3:
        m_float_vec = x.m_float_vec;
        break;
        case 4:
        m_bl = x.m_bl;
        break;
        default:
        break;
    }
}

Val::Val(Val &&x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_str = std::move(x.m_str);
        break;
        case 1:
        m_dec = x.m_dec;
        break;
        case 2:
        m_fl = x.m_fl;
        break;
        case 3:
        m_float_vec = std::move(x.m_float_vec);
        break;
        case 4:
        m_bl = x.m_bl;
        break;
        default:
        break;
    }
}

Val& Val::operator=(const Val &x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_str = x.m_str;
        break;
        case 1:
        m_dec = x.m_dec;
        break;
        case 2:
        m_fl = x.m_fl;
        break;
        case 3:
        m_float_vec = x.m_float_vec;
        break;
        case 4:
        m_bl = x.m_bl;
        break;
        default:
        break;
    }

    return *this;
}

Val& Val::operator=(Val &&x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_str = std::move(x.m_str);
        break;
        case 1:
        m_dec = x.m_dec;
        break;
        case 2:
        m_fl = x.m_fl;
        break;
        case 3:
        m_float_vec = std::move(x.m_float_vec);
        break;
        case 4:
        m_bl = x.m_bl;
        break;
        default:
        break;
    }

    return *this;
}

void Val::_d(int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        switch(__d)
        {
            case 0:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 1:
        switch(__d)
        {
            case 1:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 2:
        switch(__d)
        {
            case 2:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 3:
        switch(__d)
        {
            case 3:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 4:
        switch(__d)
        {
            case 4:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Val::_d() const
{
    return m__d;
}

int32_t& Val::_d()
{
    return m__d;
}

void Val::str(const std::string &_str)
{
    m_str = _str;
    m__d = 0;
}

void Val::str(std::string &&_str)
{
    m_str = std::move(_str);
    m__d = 0;
}

const std::string& Val::str() const
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException( ("STRING is not selected, selected is " + std::string(TYPENAMES_IDL_UNION[m__d])).data());
    }

    return m_str;
}

std::string& Val::str()
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException(("STRING is not selected, selected is " + std::string(TYPENAMES_IDL_UNION[m__d])).data());
    }

    return m_str;
}
void Val::dec(int32_t _dec)
{
    m_dec = _dec;
    m__d = 1;
}

int32_t Val::dec() const
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException(("INT is not selected, selected is " + std::string(TYPENAMES_IDL_UNION[m__d])).data());
    }

    return m_dec;
}

int32_t& Val::dec()
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException(("INT is not selected, selected is " + std::string(TYPENAMES_IDL_UNION[m__d])).data());
    }

    return m_dec;
}
void Val::fl(float _fl)
{
    m_fl = _fl;
    m__d = 2;
}

float Val::fl() const
{
    bool b = false;

    switch(m__d)
    {
        case 2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException(("FLOAT is not selected, selected is " + std::string(TYPENAMES_IDL_UNION[m__d])).data());
    }

    return m_fl;
}

float& Val::fl()
{
    bool b = false;

    switch(m__d)
    {
        case 2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException(("FLOAT is not selected, selected is " + std::string(TYPENAMES_IDL_UNION[m__d])).data());
    }

    return m_fl;
}
void Val::float_vec(const std::vector<float> &_float_vec)
{
    m_float_vec = _float_vec;
    m__d = 3;
}

void Val::float_vec(std::vector<float> &&_float_vec)
{
    m_float_vec = std::move(_float_vec);
    m__d = 3;
}

const std::vector<float>& Val::float_vec() const
{
    bool b = false;

    switch(m__d)
    {
        case 3:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException(("VECTOR_FLOAT is not selected, selected is " + std::string(TYPENAMES_IDL_UNION[m__d])).data());
    }

    return m_float_vec;
}

std::vector<float>& Val::float_vec()
{
    bool b = false;

    switch(m__d)
    {
        case 3:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException(("VECTOR_FLOAT is not selected, selected is " + std::string(TYPENAMES_IDL_UNION[m__d])).data());
    }

    return m_float_vec;
}

void Val::bl(bool _bl)
{
    m_bl = _bl;
    m__d = 4;
}

bool Val::bl() const
{
    bool b = false;

    switch(m__d)
    {
        case 4:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException(("BOOL is not selected, selected is " + std::string(TYPENAMES_IDL_UNION[m__d])).data());
    }

    return m_bl;
}

bool& Val::bl()
{
    bool b = false;

    switch(m__d)
    {
        case 4:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException(("BOOL is not selected, selected is " + std::string(TYPENAMES_IDL_UNION[m__d])).data());
    }

    return m_bl;
}

size_t Val::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4) + 255 + 1;

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);

        reset_alignment += (100 * 4) + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);



        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += 1 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t Val::getCdrSerializedSize(const Val& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 0:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.str().size() + 1;
        break;
        case 1:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case 2:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case 3:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        current_alignment += (data.float_vec().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        break;
        case 4:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Val::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 0:
        scdr << m_str;
        break;
        case 1:
        scdr << m_dec;
        break;
        case 2:
        scdr << m_fl;
        break;
        case 3:
        scdr << m_float_vec;break;
        case 4:
        scdr << m_bl;
        break;
        default:
        break;
    }
}

void Val::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 0:
        dcdr >> m_str;
        break;
        case 1:
        dcdr >> m_dec;
        break;
        case 2:
        dcdr >> m_fl;
        break;
        case 3:
        dcdr >> m_float_vec;break;
        case 4:
        dcdr >> m_bl;
        break;
        default:
        break;
    }
}



Attrib::Attrib()
{
    // m_type com.eprosima.idl.parser.typecode.PrimitiveTypeCode@15d9bc04
    m_type = 0;
    // m_value com.eprosima.idl.parser.typecode.UnionTypeCode@3c0a50da


}

Attrib::~Attrib()
{


}

Attrib::Attrib(const Attrib &x)
{
    m_type = x.m_type;
    m_value = x.m_value;
}

Attrib::Attrib(Attrib &&x)
{
    m_type = x.m_type;
    m_value = std::move(x.m_value);
}

Attrib& Attrib::operator=(const Attrib &x)
{

    m_type = x.m_type;
    m_value = x.m_value;

    return *this;
}

Attrib& Attrib::operator=(Attrib &&x)
{

    m_type = x.m_type;
    m_value = std::move(x.m_value);

    return *this;
}

size_t Attrib::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += Val::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t Attrib::getCdrSerializedSize(const Attrib& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += Val::getCdrSerializedSize(data.value(), current_alignment);

    return current_alignment - initial_alignment;
}

void Attrib::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_type;
    scdr << m_value;
}

void Attrib::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_type;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member type
 * @param _type New value for member type
 */
void Attrib::type(int32_t _type)
{
m_type = _type;
}

/*!
 * @brief This function returns the value of member type
 * @return Value of member type
 */
int32_t Attrib::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
int32_t& Attrib::type()
{
    return m_type;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void Attrib::value(const Val &_value)
{
m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void Attrib::value(Val &&_value)
{
m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const Val& Attrib::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
Val& Attrib::value()
{
    return m_value;
}

size_t Attrib::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool Attrib::isKeyDefined()
{
   return false;
}

void Attrib::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;
     
     
}

Edge::Edge()
{
    // m_to com.eprosima.idl.parser.typecode.PrimitiveTypeCode@ba8d91c
    m_to = 0;
    // m_type com.eprosima.idl.parser.typecode.StringTypeCode@7364985f
    m_type ="";
    // m_from com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5d20e46
    m_from = 0;
    // m_attrs com.eprosima.idl.parser.typecode.MapTypeCode@709ba3fb


}

Edge::~Edge()
{




}

Edge::Edge(const Edge &x)
{
    m_to = x.m_to;
    m_type = x.m_type;
    m_from = x.m_from;
    m_attrs = x.m_attrs;
}

Edge::Edge(Edge &&x)
{
    m_to = x.m_to;
    m_type = std::move(x.m_type);
    m_from = x.m_from;
    m_attrs = std::move(x.m_attrs);
}

Edge& Edge::operator=(const Edge &x)
{

    m_to = x.m_to;
    m_type = x.m_type;
    m_from = x.m_from;
    m_attrs = x.m_attrs;

    return *this;
}

Edge& Edge::operator=(Edge &&x)
{

    m_to = x.m_to;
    m_type = std::move(x.m_type);
    m_from = x.m_from;
    m_attrs = std::move(x.m_attrs);

    return *this;
}

size_t Edge::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


        current_alignment += Attrib::getMaxCdrSerializedSize(current_alignment);
    }


    return current_alignment - initial_alignment;
}

size_t Edge::getCdrSerializedSize(const Edge& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.attrs())
    {
        (void)a;
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + a.first.size() + 1;
        current_alignment += Attrib::getCdrSerializedSize((a.second), current_alignment);

    }



    return current_alignment - initial_alignment;
}

void Edge::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_to;
    scdr << m_type;
    scdr << m_from;
    scdr << m_attrs;
}

void Edge::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_to;
    dcdr >> m_type;
    dcdr >> m_from;
    dcdr >> m_attrs;
}

/*!
 * @brief This function sets a value in member to
 * @param _to New value for member to
 */
void Edge::to(int32_t _to)
{
m_to = _to;
}

/*!
 * @brief This function returns the value of member to
 * @return Value of member to
 */
int32_t Edge::to() const
{
    return m_to;
}

/*!
 * @brief This function returns a reference to member to
 * @return Reference to member to
 */
int32_t& Edge::to()
{
    return m_to;
}

/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
void Edge::type(const std::string &_type)
{
m_type = _type;
}

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
void Edge::type(std::string &&_type)
{
m_type = std::move(_type);
}

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
const std::string& Edge::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
std::string& Edge::type()
{
    return m_type;
}
/*!
 * @brief This function sets a value in member from
 * @param _from New value for member from
 */
void Edge::from(int32_t _from)
{
m_from = _from;
}

/*!
 * @brief This function returns the value of member from
 * @return Value of member from
 */
int32_t Edge::from() const
{
    return m_from;
}

/*!
 * @brief This function returns a reference to member from
 * @return Reference to member from
 */
int32_t& Edge::from()
{
    return m_from;
}

/*!
 * @brief This function copies the value in member attrs
 * @param _attrs New value to be copied in member attrs
 */
void Edge::attrs(const std::map<std::string, Attrib> &_attrs)
{
m_attrs = _attrs;
}

/*!
 * @brief This function moves the value in member attrs
 * @param _attrs New value to be moved in member attrs
 */
void Edge::attrs(std::map<std::string, Attrib> &&_attrs)
{
m_attrs = std::move(_attrs);
}

/*!
 * @brief This function returns a constant reference to member attrs
 * @return Constant reference to member attrs
 */
const std::map<std::string, Attrib>& Edge::attrs() const
{
    return m_attrs;
}

/*!
 * @brief This function returns a reference to member attrs
 * @return Reference to member attrs
 */
std::map<std::string, Attrib>& Edge::attrs()
{
    return m_attrs;
}

size_t Edge::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;







    return current_align;
}

bool Edge::isKeyDefined()
{
   return false;
}

void Edge::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;
     
     
     
     
}

EdgeKey::EdgeKey()
{
    // m_to com.eprosima.idl.parser.typecode.PrimitiveTypeCode@f0f2775
    m_to = 0;
    // m_type com.eprosima.idl.parser.typecode.StringTypeCode@5a4aa2f2
    m_type ="";

}

EdgeKey::~EdgeKey()
{


}

EdgeKey::EdgeKey(const EdgeKey &x)
{
    m_to = x.m_to;
    m_type = x.m_type;
}

EdgeKey::EdgeKey(EdgeKey &&x)
{
    m_to = x.m_to;
    m_type = std::move(x.m_type);
}

EdgeKey& EdgeKey::operator=(const EdgeKey &x)
{

    m_to = x.m_to;
    m_type = x.m_type;

    return *this;
}

EdgeKey& EdgeKey::operator=(EdgeKey &&x)
{

    m_to = x.m_to;
    m_type = std::move(x.m_type);

    return *this;
}

size_t EdgeKey::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t EdgeKey::getCdrSerializedSize(const EdgeKey& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;


    return current_alignment - initial_alignment;
}

void EdgeKey::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_to;
    scdr << m_type;
}

void EdgeKey::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_to;
    dcdr >> m_type;
}

/*!
 * @brief This function sets a value in member to
 * @param _to New value for member to
 */
void EdgeKey::to(int32_t _to)
{
m_to = _to;
}

/*!
 * @brief This function returns the value of member to
 * @return Value of member to
 */
int32_t EdgeKey::to() const
{
    return m_to;
}

/*!
 * @brief This function returns a reference to member to
 * @return Reference to member to
 */
int32_t& EdgeKey::to()
{
    return m_to;
}

/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
void EdgeKey::type(const std::string &_type)
{
m_type = _type;
}

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
void EdgeKey::type(std::string &&_type)
{
m_type = std::move(_type);
}

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
const std::string& EdgeKey::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
std::string& EdgeKey::type()
{
    return m_type;
}

size_t EdgeKey::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool EdgeKey::isKeyDefined()
{
   return false;
}

void EdgeKey::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;
     
     
}

Node::Node()
{
    // m_type com.eprosima.idl.parser.typecode.StringTypeCode@4450d156
    m_type ="";
    // m_name com.eprosima.idl.parser.typecode.StringTypeCode@4461c7e3
    m_name ="";
    // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@351d0846
    m_id = 0;
    // m_agent_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@77e4c80f
    m_agent_id = 0;
    // m_attrs com.eprosima.idl.parser.typecode.MapTypeCode@35fc6dc4

    // m_fano com.eprosima.idl.parser.typecode.MapTypeCode@7fe8ea47


}

Node::~Node()
{






}

Node::Node(const Node &x)
{
    m_type = x.m_type;
    m_name = x.m_name;
    m_id = x.m_id;
    m_agent_id = x.m_agent_id;
    m_attrs = x.m_attrs;
    m_fano = x.m_fano;
}

Node::Node(Node &&x)
{
    m_type = std::move(x.m_type);
    m_name = std::move(x.m_name);
    m_id = x.m_id;
    m_agent_id = x.m_agent_id;
    m_attrs = std::move(x.m_attrs);
    m_fano = std::move(x.m_fano);
}

Node& Node::operator=(const Node &x)
{

    m_type = x.m_type;
    m_name = x.m_name;
    m_id = x.m_id;
    m_agent_id = x.m_agent_id;
    m_attrs = x.m_attrs;
    m_fano = x.m_fano;

    return *this;
}

Node& Node::operator=(Node &&x)
{

    m_type = std::move(x.m_type);
    m_name = std::move(x.m_name);
    m_id = x.m_id;
    m_agent_id = x.m_agent_id;
    m_attrs = std::move(x.m_attrs);
    m_fano = std::move(x.m_fano);

    return *this;
}

size_t Node::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


        current_alignment += Attrib::getMaxCdrSerializedSize(current_alignment);
    }

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += EdgeKey::getMaxCdrSerializedSize(current_alignment);

        current_alignment += Edge::getMaxCdrSerializedSize(current_alignment);
    }


    return current_alignment - initial_alignment;
}

size_t Node::getCdrSerializedSize(const Node& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.attrs())
    {
        (void)a;
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + a.first.size() + 1;
        current_alignment += Attrib::getCdrSerializedSize((a.second), current_alignment);

    }


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.fano())
    {
        (void)a;
        current_alignment += EdgeKey::getCdrSerializedSize((a.first), current_alignment);
        current_alignment += Edge::getCdrSerializedSize((a.second), current_alignment);

    }



    return current_alignment - initial_alignment;
}

void Node::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_type;
    scdr << m_name;
    scdr << m_id;
    scdr << m_agent_id;
    scdr << m_attrs;
    scdr << m_fano;
}

void Node::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_type;
    dcdr >> m_name;
    dcdr >> m_id;
    dcdr >> m_agent_id;
    dcdr >> m_attrs;
    dcdr >> m_fano;
}

/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
void Node::type(const std::string &_type)
{
m_type = _type;
}

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
void Node::type(std::string &&_type)
{
m_type = std::move(_type);
}

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
const std::string& Node::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
std::string& Node::type()
{
    return m_type;
}
/*!
 * @brief This function copies the value in member name
 * @param _name New value to be copied in member name
 */
void Node::name(const std::string &_name)
{
m_name = _name;
}

/*!
 * @brief This function moves the value in member name
 * @param _name New value to be moved in member name
 */
void Node::name(std::string &&_name)
{
m_name = std::move(_name);
}

/*!
 * @brief This function returns a constant reference to member name
 * @return Constant reference to member name
 */
const std::string& Node::name() const
{
    return m_name;
}

/*!
 * @brief This function returns a reference to member name
 * @return Reference to member name
 */
std::string& Node::name()
{
    return m_name;
}
/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void Node::id(int32_t _id)
{
m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
int32_t Node::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
int32_t& Node::id()
{
    return m_id;
}

/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
void Node::agent_id(int32_t _agent_id)
{
m_agent_id = _agent_id;
}

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
int32_t Node::agent_id() const
{
    return m_agent_id;
}

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
int32_t& Node::agent_id()
{
    return m_agent_id;
}

/*!
 * @brief This function copies the value in member attrs
 * @param _attrs New value to be copied in member attrs
 */
void Node::attrs(const std::map<std::string, Attrib> &_attrs)
{
m_attrs = _attrs;
}

/*!
 * @brief This function moves the value in member attrs
 * @param _attrs New value to be moved in member attrs
 */
void Node::attrs(std::map<std::string, Attrib> &&_attrs)
{
m_attrs = std::move(_attrs);
}

/*!
 * @brief This function returns a constant reference to member attrs
 * @return Constant reference to member attrs
 */
const std::map<std::string, Attrib>& Node::attrs() const
{
    return m_attrs;
}

/*!
 * @brief This function returns a reference to member attrs
 * @return Reference to member attrs
 */
std::map<std::string, Attrib>& Node::attrs()
{
    return m_attrs;
}
/*!
 * @brief This function copies the value in member fano
 * @param _fano New value to be copied in member fano
 */
void Node::fano(const std::map<EdgeKey, Edge> &_fano)
{
m_fano = _fano;
}

/*!
 * @brief This function moves the value in member fano
 * @param _fano New value to be moved in member fano
 */
void Node::fano(std::map<EdgeKey, Edge> &&_fano)
{
m_fano = std::move(_fano);
}

/*!
 * @brief This function returns a constant reference to member fano
 * @return Constant reference to member fano
 */
const std::map<EdgeKey, Edge>& Node::fano() const
{
    return m_fano;
}

/*!
 * @brief This function returns a reference to member fano
 * @return Reference to member fano
 */
std::map<EdgeKey, Edge>& Node::fano()
{
    return m_fano;
}

size_t Node::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;









    return current_align;
}

bool Node::isKeyDefined()
{
   return false;
}

void Node::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;
     
     
     
     
     
     
}

GraphRequest::GraphRequest()
{
    // m_from com.eprosima.idl.parser.typecode.StringTypeCode@176d53b2
    m_from ="";

}

GraphRequest::~GraphRequest()
{
}

GraphRequest::GraphRequest(const GraphRequest &x)
{
    m_from = x.m_from;
}

GraphRequest::GraphRequest(GraphRequest &&x)
{
    m_from = std::move(x.m_from);
}

GraphRequest& GraphRequest::operator=(const GraphRequest &x)
{

    m_from = x.m_from;

    return *this;
}

GraphRequest& GraphRequest::operator=(GraphRequest &&x)
{

    m_from = std::move(x.m_from);

    return *this;
}

size_t GraphRequest::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    return current_alignment - initial_alignment;
}

size_t GraphRequest::getCdrSerializedSize(const GraphRequest& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.from().size() + 1;

    return current_alignment - initial_alignment;
}

void GraphRequest::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_from;
}

void GraphRequest::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_from;
}

/*!
 * @brief This function copies the value in member from
 * @param _from New value to be copied in member from
 */
void GraphRequest::from(const std::string &_from)
{
m_from = _from;
}

/*!
 * @brief This function moves the value in member from
 * @param _from New value to be moved in member from
 */
void GraphRequest::from(std::string &&_from)
{
m_from = std::move(_from);
}

/*!
 * @brief This function returns a constant reference to member from
 * @return Constant reference to member from
 */
const std::string& GraphRequest::from() const
{
    return m_from;
}

/*!
 * @brief This function returns a reference to member from
 * @return Reference to member from
 */
std::string& GraphRequest::from()
{
    return m_from;
}

size_t GraphRequest::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool GraphRequest::isKeyDefined()
{
   return false;
}

void GraphRequest::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;
     
}

PairInt::PairInt()
{
    // m_first com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2b4a2ec7
    m_first = 0;
    // m_second com.eprosima.idl.parser.typecode.PrimitiveTypeCode@18a70f16
    m_second = 0;

}

PairInt::~PairInt()
{


}

PairInt::PairInt(const PairInt &x)
{
    m_first = x.m_first;
    m_second = x.m_second;
}

PairInt::PairInt(PairInt &&x)
{
    m_first = x.m_first;
    m_second = x.m_second;
}

PairInt& PairInt::operator=(const PairInt &x)
{

    m_first = x.m_first;
    m_second = x.m_second;

    return *this;
}

PairInt& PairInt::operator=(PairInt &&x)
{

    m_first = x.m_first;
    m_second = x.m_second;

    return *this;
}

size_t PairInt::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t PairInt::getCdrSerializedSize(const PairInt& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void PairInt::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_first;
    scdr << m_second;
}

void PairInt::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_first;
    dcdr >> m_second;
}

/*!
 * @brief This function sets a value in member first
 * @param _first New value for member first
 */
void PairInt::first(int32_t _first)
{
m_first = _first;
}

/*!
 * @brief This function returns the value of member first
 * @return Value of member first
 */
int32_t PairInt::first() const
{
    return m_first;
}

/*!
 * @brief This function returns a reference to member first
 * @return Reference to member first
 */
int32_t& PairInt::first()
{
    return m_first;
}

/*!
 * @brief This function sets a value in member second
 * @param _second New value for member second
 */
void PairInt::second(int32_t _second)
{
m_second = _second;
}

/*!
 * @brief This function returns the value of member second
 * @return Value of member second
 */
int32_t PairInt::second() const
{
    return m_second;
}

/*!
 * @brief This function returns a reference to member second
 * @return Reference to member second
 */
int32_t& PairInt::second()
{
    return m_second;
}


size_t PairInt::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool PairInt::isKeyDefined()
{
   return false;
}

void PairInt::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;
     
     
}

DotContext::DotContext()
{
    // m_cc com.eprosima.idl.parser.typecode.MapTypeCode@6279cee3

    // m_dc com.eprosima.idl.parser.typecode.SequenceTypeCode@4206a205


}

DotContext::~DotContext()
{


}

DotContext::DotContext(const DotContext &x)
{
    m_cc = x.m_cc;
    m_dc = x.m_dc;
}

DotContext::DotContext(DotContext &&x)
{
    m_cc = std::move(x.m_cc);
    m_dc = std::move(x.m_dc);
}

DotContext& DotContext::operator=(const DotContext &x)
{

    m_cc = x.m_cc;
    m_dc = x.m_dc;

    return *this;
}

DotContext& DotContext::operator=(DotContext &&x)
{

    m_cc = std::move(x.m_cc);
    m_dc = std::move(x.m_dc);

    return *this;
}

size_t DotContext::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    }

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += PairInt::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t DotContext::getCdrSerializedSize(const DotContext& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.cc())
    {
        (void)a;
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    }


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.dc().size(); ++a)
    {
        current_alignment += PairInt::getCdrSerializedSize(data.dc().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void DotContext::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_cc;
    scdr << m_dc;
}

void DotContext::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_cc;
    dcdr >> m_dc;
}

/*!
 * @brief This function copies the value in member cc
 * @param _cc New value to be copied in member cc
 */
void DotContext::cc(const std::map<int32_t, int32_t> &_cc)
{
m_cc = _cc;
}

/*!
 * @brief This function moves the value in member cc
 * @param _cc New value to be moved in member cc
 */
void DotContext::cc(std::map<int32_t, int32_t> &&_cc)
{
m_cc = std::move(_cc);
}

/*!
 * @brief This function returns a constant reference to member cc
 * @return Constant reference to member cc
 */
const std::map<int32_t, int32_t>& DotContext::cc() const
{
    return m_cc;
}

/*!
 * @brief This function returns a reference to member cc
 * @return Reference to member cc
 */
std::map<int32_t, int32_t>& DotContext::cc()
{
    return m_cc;
}
/*!
 * @brief This function copies the value in member dc
 * @param _dc New value to be copied in member dc
 */
void DotContext::dc(const std::vector<PairInt> &_dc)
{
m_dc = _dc;
}

/*!
 * @brief This function moves the value in member dc
 * @param _dc New value to be moved in member dc
 */
void DotContext::dc(std::vector<PairInt> &&_dc)
{
m_dc = std::move(_dc);
}

/*!
 * @brief This function returns a constant reference to member dc
 * @return Constant reference to member dc
 */
const std::vector<PairInt>& DotContext::dc() const
{
    return m_dc;
}

/*!
 * @brief This function returns a reference to member dc
 * @return Reference to member dc
 */
std::vector<PairInt>& DotContext::dc()
{
    return m_dc;
}

size_t DotContext::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool DotContext::isKeyDefined()
{
   return false;
}

void DotContext::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;
     
     
}

DotKernel::DotKernel()
{
    // m_ds com.eprosima.idl.parser.typecode.MapTypeCode@77e9807f

    // m_cbase com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@448ff1a8


}

DotKernel::~DotKernel()
{


}

DotKernel::DotKernel(const DotKernel &x)
{
    m_ds = x.m_ds;
    m_cbase = x.m_cbase;
}

DotKernel::DotKernel(DotKernel &&x)
{
    m_ds = std::move(x.m_ds);
    m_cbase = std::move(x.m_cbase);
}

DotKernel& DotKernel::operator=(const DotKernel &x)
{

    m_ds = x.m_ds;
    m_cbase = x.m_cbase;

    return *this;
}

DotKernel& DotKernel::operator=(DotKernel &&x)
{

    m_ds = std::move(x.m_ds);
    m_cbase = std::move(x.m_cbase);

    return *this;
}

size_t DotKernel::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += PairInt::getMaxCdrSerializedSize(current_alignment);

        current_alignment += Node::getMaxCdrSerializedSize(current_alignment);
    }

    current_alignment += DotContext::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t DotKernel::getCdrSerializedSize(const DotKernel& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.ds())
    {
        (void)a;
        current_alignment += PairInt::getCdrSerializedSize((a.first), current_alignment);
        current_alignment += Node::getCdrSerializedSize((a.second), current_alignment);

    }


    current_alignment += DotContext::getCdrSerializedSize(data.cbase(), current_alignment);

    return current_alignment - initial_alignment;
}

void DotKernel::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_ds;
    scdr << m_cbase;
}

void DotKernel::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_ds;
    dcdr >> m_cbase;
}

/*!
 * @brief This function copies the value in member ds
 * @param _ds New value to be copied in member ds
 */
void DotKernel::ds(const std::map<PairInt, Node> &_ds)
{
m_ds = _ds;
}

/*!
 * @brief This function moves the value in member ds
 * @param _ds New value to be moved in member ds
 */
void DotKernel::ds(std::map<PairInt, Node> &&_ds)
{
m_ds = std::move(_ds);
}

/*!
 * @brief This function returns a constant reference to member ds
 * @return Constant reference to member ds
 */
const std::map<PairInt, Node>& DotKernel::ds() const
{
    return m_ds;
}

/*!
 * @brief This function returns a reference to member ds
 * @return Reference to member ds
 */
std::map<PairInt, Node>& DotKernel::ds()
{
    return m_ds;
}
/*!
 * @brief This function copies the value in member cbase
 * @param _cbase New value to be copied in member cbase
 */
void DotKernel::cbase(const DotContext &_cbase)
{
m_cbase = _cbase;
}

/*!
 * @brief This function moves the value in member cbase
 * @param _cbase New value to be moved in member cbase
 */
void DotKernel::cbase(DotContext &&_cbase)
{
m_cbase = std::move(_cbase);
}

/*!
 * @brief This function returns a constant reference to member cbase
 * @return Constant reference to member cbase
 */
const DotContext& DotKernel::cbase() const
{
    return m_cbase;
}

/*!
 * @brief This function returns a reference to member cbase
 * @return Reference to member cbase
 */
DotContext& DotKernel::cbase()
{
    return m_cbase;
}

size_t DotKernel::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool DotKernel::isKeyDefined()
{
   return false;
}

void DotKernel::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;
     
     
}

AworSet::AworSet()
{
    // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@44a664f2
    m_id = 0;
    // m_dk com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@7f9fcf7f


}

AworSet::~AworSet()
{


}

AworSet::AworSet(const AworSet &x)
{
    m_id = x.m_id;
    m_dk = x.m_dk;
}

AworSet::AworSet(AworSet &&x)
{
    m_id = x.m_id;
    m_dk = std::move(x.m_dk);
}

AworSet& AworSet::operator=(const AworSet &x)
{

    m_id = x.m_id;
    m_dk = x.m_dk;

    return *this;
}

AworSet& AworSet::operator=(AworSet &&x)
{

    m_id = x.m_id;
    m_dk = std::move(x.m_dk);

    return *this;
}

size_t AworSet::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += DotKernel::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t AworSet::getCdrSerializedSize(const AworSet& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += DotKernel::getCdrSerializedSize(data.dk(), current_alignment);

    return current_alignment - initial_alignment;
}

void AworSet::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_id;
    scdr << m_dk;
}

void AworSet::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_id;
    dcdr >> m_dk;
}

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void AworSet::id(int32_t _id)
{
m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
int32_t AworSet::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
int32_t& AworSet::id()
{
    return m_id;
}

/*!
 * @brief This function copies the value in member dk
 * @param _dk New value to be copied in member dk
 */
void AworSet::dk(const DotKernel &_dk)
{
m_dk = _dk;
}

/*!
 * @brief This function moves the value in member dk
 * @param _dk New value to be moved in member dk
 */
void AworSet::dk(DotKernel &&_dk)
{
m_dk = std::move(_dk);
}

/*!
 * @brief This function returns a constant reference to member dk
 * @return Constant reference to member dk
 */
const DotKernel& AworSet::dk() const
{
    return m_dk;
}

/*!
 * @brief This function returns a reference to member dk
 * @return Reference to member dk
 */
DotKernel& AworSet::dk()
{
    return m_dk;
}

size_t AworSet::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool AworSet::isKeyDefined()
{
   return false;
}

void AworSet::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;
     
     
}

OrMap::OrMap()
{
    // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@145eaa29
    m_id = 0;
    // m_m com.eprosima.idl.parser.typecode.MapTypeCode@15bb6bea

    // m_cbase com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@448ff1a8


}

OrMap::~OrMap()
{



}

OrMap::OrMap(const OrMap &x)
{
    m_id = x.m_id;
    m_m = x.m_m;
    m_cbase = x.m_cbase;
}

OrMap::OrMap(OrMap &&x)
{
    m_id = x.m_id;
    m_m = std::move(x.m_m);
    m_cbase = std::move(x.m_cbase);
}

OrMap& OrMap::operator=(const OrMap &x)
{

    m_id = x.m_id;
    m_m = x.m_m;
    m_cbase = x.m_cbase;

    return *this;
}

OrMap& OrMap::operator=(OrMap &&x)
{

    m_id = x.m_id;
    m_m = std::move(x.m_m);
    m_cbase = std::move(x.m_cbase);

    return *this;
}

size_t OrMap::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



        current_alignment += AworSet::getMaxCdrSerializedSize(current_alignment);
    }

    current_alignment += DotContext::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t OrMap::getCdrSerializedSize(const OrMap& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.m())
    {
        (void)a;
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += AworSet::getCdrSerializedSize((a.second), current_alignment);

    }


    current_alignment += DotContext::getCdrSerializedSize(data.cbase(), current_alignment);

    return current_alignment - initial_alignment;
}

void OrMap::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_id;
    scdr << m_m;
    scdr << m_cbase;
}

void OrMap::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_id;
    dcdr >> m_m;
    dcdr >> m_cbase;
}

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void OrMap::id(int32_t _id)
{
m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
int32_t OrMap::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
int32_t& OrMap::id()
{
    return m_id;
}

/*!
 * @brief This function copies the value in member m
 * @param _m New value to be copied in member m
 */
void OrMap::m(const std::map<int32_t, AworSet> &_m)
{
m_m = _m;
}

/*!
 * @brief This function moves the value in member m
 * @param _m New value to be moved in member m
 */
void OrMap::m(std::map<int32_t, AworSet> &&_m)
{
m_m = std::move(_m);
}

/*!
 * @brief This function returns a constant reference to member m
 * @return Constant reference to member m
 */
const std::map<int32_t, AworSet>& OrMap::m() const
{
    return m_m;
}

/*!
 * @brief This function returns a reference to member m
 * @return Reference to member m
 */
std::map<int32_t, AworSet>& OrMap::m()
{
    return m_m;
}
/*!
 * @brief This function copies the value in member cbase
 * @param _cbase New value to be copied in member cbase
 */
void OrMap::cbase(const DotContext &_cbase)
{
m_cbase = _cbase;
}

/*!
 * @brief This function moves the value in member cbase
 * @param _cbase New value to be moved in member cbase
 */
void OrMap::cbase(DotContext &&_cbase)
{
m_cbase = std::move(_cbase);
}

/*!
 * @brief This function returns a constant reference to member cbase
 * @return Constant reference to member cbase
 */
const DotContext& OrMap::cbase() const
{
    return m_cbase;
}

/*!
 * @brief This function returns a reference to member cbase
 * @return Reference to member cbase
 */
DotContext& OrMap::cbase()
{
    return m_cbase;
}

size_t OrMap::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool OrMap::isKeyDefined()
{
   return false;
}

void OrMap::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;
     
     
     
}
